// In C++ we usually read input into std::string objects, e.g.:
// std::string s;
// std::cin >> s;
// But sometimes we want exactly N characters (even if spaces or newlines are included).
// The normal >> operator won‚Äôt work for that, because it skips whitespace and stops at spaces.
// That‚Äôs where cin.get() is used.


// 2. cin.get() behavior
    // cin.get() has multiple forms:
        // cin.get() ‚Üí reads one single character.
        // cin.get(char* buffer, int size) ‚Üí reads up to size-1 characters into a C-style char array.

    // cin.get(char* buffer, int size) requires a char array, because it places characters directly in that memory.
        // char buffer[11]; // array of 11 chars
        // std::cin.get(buffer, 11); // read up to 10 characters (one spot left for '\0')

    // Now buffer contains those characters as a C-string (null-terminated).
    // But if you want a std::string (the C++ object), you must convert:
        // std::string s(buffer);

/*
#include <iostream>
#include <string>
using namespace std;

int main() {
    char buffer[11]; // reserve space for 10 chars + null terminator

    cout << "Enter text: ";
    cin.get(buffer, 11); // reads up to 10 chars (stops before newline or size)

    string s(buffer); // convert char array to std::string
    cout << "You entered: " << s << endl;

    return 0;
}
*/
/*
If you type:
    Hello World!

It will only read:
    Hello Worl

(10 characters).
*/

/*
Summary:
    cin.get() with parameters needs a char array.
    It cannot write directly into a std::string.
*/

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
You can save into a std::string, but the catch is:

cin.get(char* buffer, int size) is an old C-style function.

It expects a raw memory buffer (char[]) where it will physically copy characters.

A std::string is an object, not just a raw character array. You cannot pass it directly, because cin.get doesn‚Äôt know how to 
‚Äúfill‚Äù the internals of the object safely.
*/

/*
1. Why std::string doesn‚Äôt work with cin.get
    If you try this:
    string s;
    cin.get(s, 11);  // ‚ùå error: no matching function
    It won‚Äôt compile, because there is no overload of cin.get that accepts a std::string.
*/

/*
2. But there is an alternative: cin.read()
    C++ gives another method designed for reading raw characters into memory that works better with std::string.

    Example:

    #include <iostream>
    #include <string>
    using namespace std;

    int main() {
        string s(10, '\0'); // make a string with 10 slots (filled with '\0')

        cout << "Enter text: ";
        cin.read(&s[0], 10); // read 10 characters directly into the string‚Äôs buffer

        cout << "You entered: " << s << endl;
        return 0;
    }

    If you type:
        Hello World!


    It will output:
        Hello Worl

    üëâ Here we avoided the intermediate char array ‚Äî we read directly into the std::string memory.
*/

/*
3. When to use which

    Use cin.get(char*, int) ‚Üí if you‚Äôre working with raw C-style arrays.
    Use cin.read(&s[0], n) ‚Üí if you want to read directly into a std::string.
*/


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
1. What is char[]?

    char[] is a C-style character array.

    It is literally a block of memory that can hold multiple characters (letters, digits, symbols, spaces).

    Example:
    char word[6]; 
    This reserves 6 bytes in memory (1 byte per char).
*/

/*
2. Why is it special for text?

    In C and C++, strings in the C-style are just arrays of characters ending with a special character: '\0' (null terminator).
    So, if we write:
    char word[6] = "Hello";

    Memory looks like this:

    Index	Value
    0	'H'
    1	'e'
    2	'l'
    3	'l'
    4	'o'
    5	'\0'

    üëâ That '\0' tells functions where the string ends.
*/

/*
Example of risk with char[]:

char name[5];
cin >> name; // if you type "Hello", overflow happens (needs 6 chars: "Hello\0")

Quick analogy

char[] ‚Üí Like a fixed-size box of letters; you must decide the size before writing, and you must put a ‚ÄúTHE END‚Äù card ('\0') yourself.

std::string ‚Üí Like a flexible notebook that can grow automatically and keeps track of its own ending.



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

1. What is function overloading?

    In C++, overloading means you can define multiple functions with the same name, but with different parameter lists.
    The compiler then decides which version to call depending on the arguments you pass.

    Example:

        #include <iostream>
        using namespace std;

        void print(int x) {
            cout << "Integer: " << x << endl;
        }

        void print(double y) {
            cout << "Double: " << y << endl;
        }

        void print(string s) {
            cout << "String: " << s << endl;
        }

        int main() {
            print(5);        // calls print(int)
            print(3.14);     // calls print(double)
            print("Hello");  // calls print(string)
        }

Here print is overloaded with 3 different signatures:

    print(int)
    print(double)
    print(string)



2. How it applies to cin.get

    The standard library has several overloads of cin.get.
    Some of them are:

        cin.get() ‚Üí reads one character.
        cin.get(char &c) ‚Üí stores one character in a variable you provide.
        cin.get(char* buffer, int size) ‚Üí reads up to size-1 characters into a character array.

    üëâ Notice: there is no version (overload) of cin.get that takes a std::string. That‚Äôs why this fails:

        std::string s;
        cin.get(s, 11);  // ‚ùå compiler error: no matching function

    Because the compiler looks through all the overloaded cin.get functions and sees:
    ‚ÄúI don‚Äôt have one that matches (std::string, int).‚Äù


3. Term clarified
    So when I said:

        ‚Äúthere is no overload of cin.get that accepts a std::string.‚Äù
        I meant:
        The cin.get family has several versions (overloads).
        But none of them are written to accept a std::string as an argument.


‚úÖ Summary:

    Overload in C++ means: same function name, different parameter list.
    The compiler picks the correct version at compile time.
    cin.get is overloaded for char, char*, etc.
    It is not overloaded for std::string, so you can‚Äôt use it that way.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


3. What will be stored

    If you type "Hello World!" into text[6], you won‚Äôt get just "Hello". Instead, you‚Äôll overflow the array.
    The first 6 slots will be filled ('H', 'e', 'l', 'l', 'o', maybe part of the space or null).
    Then input keeps writing into memory that doesn‚Äôt belong to text.
    That‚Äôs the danger ‚Äî unlike std::string, a char[] has no built-in safety check.

4. Safer alternative

    With std::string, you don‚Äôt have this problem:
        std::string text;
        cin >> text;
    Now if you type "Hello World!", it will safely store "Hello" (because >> stops at the space).
    Or if you use getline(cin, text);, it will safely store the entire line, growing the string automatically.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Pointer is a variable that points to the address of another variable. it stores address of another variable

int a;
int *p;
p = &a;
a = 5;
print p;  //204 because this holds the address of the variable a
print &a;  //204 
print &p;  //64 this points to the address of variable p
print *p;  //5 this returns the value of the variable a

so:
p -> Address which p holds
*p -> value at address which p holds



1. Declaring a pointer

    If you want a pointer to an int, you declare it like this:
        int *p;   // p is a pointer to int
    Here, p itself does not point anywhere yet. It's uninitialized, so using it before assigning is dangerous.

2. Making it point to an existing variable

    You make a pointer point to a variable by using the address-of operator (&):

        int b = 10;
        int *p = &b;  // p now points to b

    So now:
    p holds the memory address of b.
    *p (dereferencing) gives you the value of b.


#include <iostream>
using namespace std;
int main()
{
    int a = 10;
    int *b;
    b= &a;
    cout << "a= " << a << endl;
    cout << "b= " << b << endl;
    cout << "b= " << &b << endl;
    cout << "b= " << *b << endl;
    
    *b = 40; // Here we have changed value of the variable which b is refering to. so b also will change
    
    cout << "a= " << a << endl;
    cout << "b= " << b << endl;
    cout << "b= " << &b << endl;
    cout << "b= " << *b << endl;
    return 0;
}


3. Important distinction

    int p; ‚Üí p is a regular integer variable (not a pointer).
    int *p; ‚Üí p is a pointer to an integer.
    You cannot do something like:

        int b = 10;
        int p = &b; // ‚ùå WRONG: &b is an address, but p is just an int

    That would be a type mismatch ‚Äî &b has type int*, not int.



    *p = 20;
‚Üí *p means ‚Äúthe value at the memory location that p points to‚Äù.
Since p points to a, this line sets a = 20.

Final result:

    a == 20 ‚úÖ
    b == 20 ‚úÖ (unchanged after declaration)
    *p == 20 ‚úÖ (because p points to a)

So yes ‚Äî the value of a will change.

‚ö° Key point:
    *p = 20; modifies the variable that p points to (in this case a).

We can also write in both of the below forms:
int* p = &a;
int *p = &a;



If we use just the name of the array it will point to the address of the first element in the array

    int A[5] = {10, 20, 30, 40, 50};
    int *p;
    p=A;
    cout << A << endl; // Address of the first element in the array like 200
    cout << *A << endl; // Value stored in the first element of the array like 10
    cout << A+1 << endl; // Address of the second element in the array like 204
    cout << *(A+1) << endl; // Value stored in the second element of the array like 20

    cout << A << endl; // Address of the first element in the array like 200
    cout << &A[0] << endl; // Address of the first element in the array like 200
    cout << A[0] << endl; // Value of the first element in the array like 10
    cout << *A << endl; // Value of the first element in the array like 10


    A++; // This is invalid and makes error
    p++; // This is valid and will work

Step 3: p = A;
    Since A can be treated as the address of its first element:
    A is equivalent to &A[0]
    So now p = &A[0] (i.e., p points to the first element of the array).


Step 4: print A;
    If you try to std::cout << A; in C++:
    It will print the memory address of the first element (like 0x7ffee....), not the whole array.
    A is essentially a pointer here.


Step 5: print *A;
    *A means ‚Äúthe value stored at address A‚Äù
    Since A == &A[0], dereferencing gives the first element: A[0].
    So *A is exactly the same as A[0].    



** To get the address of the second element in array we can use either of the below ways.

    &A[i]
    (A+1)

** To get the value of the second element in array we can use either of the below ways.

    A[i]
    *(A+1)

The address of the first element in the array can be called the base address

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Arrays as function arguments

** Arrays are always passed to functions by the reference and not whole the array will be passed to the the function.
it means that only the address of the first member of the array will be passed to the function

int A[5];
int *p = A; // This will put the address of the first element of A which is A[0] in the variable p
print A; // this will be the address of the first element in array A for example 200
print *A // this will be the value which the first address of the array A is storing for example 10
print *(A+2) // this will be the value of the third element of array A which for example is 6

** So for conclusion (A+i) is the same as A[i] which gives the address of the i+1 member of the array A
** so for conclusion *(A+i) is the same and &A[i] which gives the address of the i+1 member of the array A




    int A[5] = {10, 20, 30, 40, 50};
    int size = sizeof(A);
    int sizeofarray = sizeof(A)/sizeof(A[0]);
    cout << size << endl;
    cout << sizeofarray << endl;



int B [2][3] // Here we are creating two 1-D arrays which each one has 3 member
B[0]
B[1]

each on these 1-D arrays have 12 bytes length because of 3*4bytes = 12 bytes
so for example B[0] starts from address 400 to 411 and the array B[1] starts from 412 to 423


** Name of the array points to the address of the first member of the array

B is a 2D array of type int[2][3].
In most expressions, B decays into a pointer to its first row.
So B is of type int (*)[3] (pointer to an array of 3 ints).



    #include <iostream>
    using namespace std;

    int main() {
        int B[2][3];   // a 2x3 array

        int *p = B;    // ‚ùå problem is here

        return 0;
    }

here we have this situation:

    int *p = B;   // trying to assign int (*)[3] to int*

p expects a pointer to an int.
But B decays to a pointer to an array of 3 ints (int (*)[3]).
These are not the same type, so the compiler complains.



Correct ways
    If you really want p to point to the first element (an int):

        int *p = &B[0][0];  // point to the very first int in the 2D array

    If you want a pointer to a row:

        int (*p)[3] = B;    // p is a pointer to an array of 3 ints

    Now you can do:

        cout << (*p)[0];   // first element of first row
        p++;  


üîπ Example 1: Accessing elements with int* p = &B[0][0];
    #include <iostream>
    using namespace std;

    int main() {
        int B[2][3] = { {1, 2, 3}, {4, 5, 6} };

        int *p = &B[0][0];   // pointer to the first int in the 2D array

        // Print elements using pointer arithmetic
        for (int i = 0; i < 6; i++) {
            cout << *(p + i) << " ";
        }
        cout << endl;
    }

üîπ Output:
    1 2 3 4 5 6



üîπ Example 2: Pointer to a row (int (*p)[3] = B;)
    #include <iostream>
    using namespace std;

    int main() {
        int B[2][3] = { {1, 2, 3}, {4, 5, 6} };

        int (*p)[3] = B;   // p points to a row of 3 integers

        // Access elements row by row
        cout << "First row: " << (*p)[0] << " " << (*p)[1] << " " << (*p)[2] << endl;

        p++;   // move to next row (skips 3 ints)

        cout << "Second row: " << (*p)[0] << " " << (*p)[1] << " " << (*p)[2] << endl;
    }

üîπ Output:
    First row: 1 2 3
    Second row: 4 5 6

üîπ Explanation:

    p is a pointer to an array of 3 ints.
    *p dereferences to the whole row (int[3]).
    (*p)[i] accesses elements within that row.
    p++ moves to the next row (jumps by 3 ints at once).



üîπ 1. What does [3] mean in this declaration?
    int (*p)[3] = B;

    p is a pointer.
    (*p)[3] means: "p points to an array of 3 integers".
    So p has type pointer to array of 3 ints (int (*)[3]).
    This is different from int *p (pointer to a single int).


üîπ 2. Is the row an array?

Yes ‚úÖ Each row in B is an array of 3 integers.

For example:

    int B[2][3] = { {1,2,3}, {4,5,6} };

    B[0] ‚Üí the first row, type int[3].
    B[1] ‚Üí the second row, type int[3].

So when you write:
    int (*p)[3] = B;

    p = &B[0] // This means put the address of B[0] which is an aray of 3 ints in pointer p so pointer p should be defined as pointer 
    with dimention of array of 3 ints

    *p = B[0] (which is an array of 3 ints).



üîπ 3. Why can‚Äôt I just cout << *p; to print the row?

    This is because of how arrays behave in C++:
    *p is of type int[3] (array of 3 ints).
    But in most expressions, an array decays into a pointer to its first element.
    So *p decays into int* ‚Üí pointer to (*p)[0].
    That‚Äôs why:

        cout << *p;
    prints the address of the first element (&B[0][0]), not the whole array.

    ‚ö° Key point: C++ does not know how to print arrays directly with cout.
    It only knows how to print scalars (int, double, etc.) and addresses (int*).



üîπ 4. ‚Äú*p dereferences to the whole row‚Äù ‚Äî what does that mean?

    p ‚Üí pointer to a row (int (*)[3]).
    *p ‚Üí the row itself (int[3]).

    But as soon as you use *p in an expression (like with cout), it decays to int* (address of first element).
    So in practice:
    *p is conceptually the whole row {1,2,3}.
    But C++ treats it as just the address of the first element.
    That‚Äôs why you need a loop to see all elements:

        for (int i = 0; i < 3; i++) {
            cout << (*p)[i] << " ";
        }

    Output:
        1 2 3



1. Can you do cout << B[0]; ?

        int B[2][3] = { {1,2,3}, {4,5,6} };
        cout << B[0] << endl;

    B[0] is the first row. Its type is int[3].
    In most expressions (like here), it decays to a pointer ‚Üí type int* (pointer to the first element of that row).
    So cout << B[0]; will just print the address of B[0][0], not the values {1,2,3}.
    ‚úÖ If you want the row values, you must loop:

        for (int i = 0; i < 3; i++) {
            cout << B[0][i] << " ";
        }

    Output:

        1 2 3




#include <iostream>
using namespace std;
int main()
{
    int B[2][3]={{1,2,3},{4,5,6}};
    
    int *p = B[0];
    // int *z = &B[0]; // This will generate compiler error
    cout << &B[0][0] << endl;
    cout << &B[0][1] << endl;
    cout << &B[0][2] << endl;
    cout << &B[1][0] << endl;
    cout << &B[1][1] << endl;
    cout << &B[1][2] << endl<<endl;
    cout << p << endl;
    cout << *p << endl;
    cout << p+1 << endl;
    cout << *(p+1) << endl;
    return 0;
}


output:
    0x7ffc3b3d95b0
    0x7ffc3b3d95b4
    0x7ffc3b3d95b8
    0x7ffc3b3d95bc
    0x7ffc3b3d95c0
    0x7ffc3b3d95c4

    0x7ffc3b3d95b0
    1
    0x7ffc3b3d95b4
    2



üîπ 1. B[0]

    B[0] is the first row, type int[3].
    In most expressions, an array decays into a pointer to its first element ‚Üí int*.
    So:

        B[0]   ‚Üí int[3] ‚Üí decays to int* ‚Üí &B[0][0]

    Example:

        int *p = B[0];   // OK
        cout << p;       // prints address of B[0][0]


üîπ 2. &B[0]

    &B[0] means ‚Äúthe address of the entire first row‚Äù.
    Type is pointer to an array of 3 ints ‚Üí int (*)[3].
    So:

        &B[0]   ‚Üí int (*)[3]

    Example:

        int (*z)[3] = &B[0];  // z points to the row (not just an int)
        cout << z;            // prints same address as &B[0][0]


üîπ 3. Why do they both print the same address?

    Because both ultimately refer to the same chunk of memory, the start of row 0:

        B[0][0]   B[0][1]   B[0][2]   B[1][0]   B[1][1]   B[1][2]
        ‚Üë
        |__ start of row 0  ‚Üí  address(&B[0]) == address(B[0]) == address(&B[0][0])


    So numerically the addresses are the same.
    But semantically they‚Äôre different types:

        B[0] (decayed) ‚Üí int* (pointer to element).
        &B[0] ‚Üí int (*)[3] (pointer to row).


üîπ 4. Why does the type matter?

    üëâ Look at what happens when you increment:

        int *p = B[0];     // points to B[0][0]
        int (*z)[3] = &B[0]; // points to the row

        cout << (p+1) << endl;   // moves by 1 int ‚Üí points to B[0][1]
        cout << (z+1) << endl;   // moves by 1 row ‚Üí points to B[1][0]


    ‚ö° That‚Äôs the key difference:

    int* moves by 1 element at a time.
    int (*)[3] moves by 1 row at a time.

‚úÖ Summary

    B[0] ‚Üí row ‚Üí decays to int* ‚Üí points to first element of row.
    &B[0] ‚Üí address of row ‚Üí int (*)[3].
    Both print the same address, because the row starts at its first element.
    But when you increment them:
    p++ ‚Üí walks inside the row.
    z++ ‚Üí jumps to the next row.



    #include <iostream>
    using namespace std;
    int main()
    {
        int A[5] = {1,2,3,4,5};
        int *p=A;
        //int *x = &A; //This will generate error because &A is pointing to the address of the whole row just like the case above explained
        //it is trying to convert ‚Äòint (*)[5]‚Äô to ‚Äòint*‚Äô. The types are not matched
        //int *y = A[0]; // this will generate error because it is trying to invalid conversion from ‚Äòint‚Äô to ‚Äòint*‚Äô. we need to put the address of first element in array in pointer
        int *z = &A[0];
        
        cout << p << endl;
        cout << *p << endl;
        cout << &p << endl;    
        cout << z << endl;
        cout << *z << endl;
        cout << &z << endl;    

        return 0;
    }

output:

    0x7fff2f304350
    1
    0x7fff2f304340
    0x7fff2f304350
    1
    0x7fff2f304348



** SUMMARY
print B = print &B[0] // This gives the address of the first row of the Array B which means B[0] but the compiler will point to the 
                      // first element of that array B[0]


    #include <iostream>
    using namespace std;
    int main()
    {
        int B[2][3]={{1,2,3},{4,5,9}};
        
        cout << "B: " << B << endl;
        cout << "&B[0]: " << &B[0] << endl;
        cout << "&B: " << &B << endl;
        cout << "&B[0][0]: " << &B[0][0] << endl;
        cout << "*B: " << *B << endl;
        cout << "**B: " << **B << endl;
        cout << "*B[0]: " << *B[0] << endl;
        cout << "*(B+1): " << *(B+1) << endl;
        cout << "*(B+1)+2: " << *(B+1)+2 << endl;
        cout << "*(*(B+1)+2): " << *(*(B+1)+2) << endl;
        cout << "**(B+1)+2: " << **(B+1)+2 << endl;
        cout << "**((B+1)+1): " << **((B+1)+1) << endl;
        cout << "*(*B+1): " << *(*B+1) << endl;
        cout << "&B[0][1]: " << &B[0][1] << endl;
        cout << "&B[0][2]: " << &B[0][2] << endl;
        cout << "&B[1][0]: " << &B[1][0] << endl;
        cout << "&B[1][1]: " << &B[1][1] << endl;
        cout << "&B[1][2]: " << &B[1][2] << endl<<endl;
        
        
        return 0;
    }


Output:
    B: 0x7ffca5ac6000
    &B[0]: 0x7ffca5ac6000
    &B: 0x7ffca5ac6000
    &B[0][0]: 0x7ffca5ac6000
    *B: 0x7ffca5ac6000
    **B: 1
    *B[0]: 1
    *(B+1): 0x7ffca5ac600c
    *(B+1)+2: 0x7ffca5ac6014
    *(*(B+1)+2): 9
    **(B+1)+2: 6
    **((B+1)+1): -453830400
    *(*B+1): 2
    &B[0][1]: 0x7ffca5ac6004
    &B[0][2]: 0x7ffca5ac6008
    &B[1][0]: 0x7ffca5ac600c
    &B[1][1]: 0x7ffca5ac6010
    &B[1][2]: 0x7ffca5ac6014


üîπ Memory layout of B

    B is a 2x3 array of ints:

    B[0][0]  B[0][1]  B[0][2]  B[1][0]  B[1][1]  B[1][2]
    1        2        3        4        5        6

    In memory, these 6 ints are contiguous.




‚úÖ Why do many of them look the same?

    Because they all refer to the start of the array in memory.
    But the types are different, which affects pointer arithmetic:

        B / &B[0] ‚Üí type int (*)[3] (pointer to row).
        &B ‚Üí type int (*)[2][3] (pointer to whole 2x3 array).
        &B[0][0] ‚Üí type int* (pointer to element).
        *B ‚Üí row, decays to int* (pointer to first element).
        *B[0] ‚Üí value of first element = 1.



üîπ What is B?
        int B[2][3] = { {1,2,3}, {4,5,6} };


    B is a 2D array: int[2][3].
    In most expressions, B decays to:

        int (*)[3]   // pointer to an array of 3 ints (a row)

    So:
        B ‚Üí points to the first row.

üîπ Case 1: B + 1

    Type of B (after decay): int (*)[3].
        That means "B is a pointer to an array of 3 ints."
    When you do B+1, pointer arithmetic applies:

        B+1 ‚Üí moves forward by 1 row (int[3]).

    Skips 3 integers (12 bytes if int=4).
    So:

        B       ‚Üí &B[0] (address of row 0, {1,2,3})
        B + 1   ‚Üí &B[1] (address of row 1, {4,5,6})

        ‚úÖ B+1 = "go to the next row."


üîπ Case 2: &B + 1

        &B is the address of the entire array.
        Type: int (*)[2][3] (pointer to a 2x3 array).

    So &B + 1 means:

        "Go forward by 1 whole array (int[2][3])."
        That skips 6 integers (24 bytes if int=4).

    So:

        &B       ‚Üí address of the whole 2x3 array
        &B + 1   ‚Üí address just past the entire array (like end pointer)



üîπ Visual Layout

    Memory for B:

        Row 0:  [1][2][3]
        Row 1:  [4][5][6]

    Addresses (example):

        & B[0][0] = 1000
        & B[0][1] = 1004
        & B[0][2] = 1008
        & B[1][0] = 1012
        & B[1][1] = 1016
        & B[1][2] = 1020

    Now:

        B      = &B[0]   = 1000
        B+1    = &B[1]   = 1012   (moved by 3 ints)

        &B     = address of whole array = 1000
        &B+1   = 1024    (moved by 6 ints, whole 2x3 block)


‚úÖ Summary

    B ‚Üí pointer to row ‚Üí B+1 jumps to the next row.
    &B ‚Üí pointer to entire array ‚Üí &B+1 jumps past the entire 2x3 array.





Let‚Äôs carefully unpack why *B prints an address instead of the value.

üîπ Step 1: What is B?

    B is a 2D array: int B[2][3];
    Type of B is int[2][3].
    In most expressions, B decays into a pointer to its first row ‚Üí int (*)[3].
    So:
        B   ‚Üí type int (*)[3]   (pointer to a row of 3 ints)


üîπ Step 2: What is *B?

    If B is int (*)[3] (pointer to row),
    then *B dereferences that pointer ‚Üí the first row.
    First row is an array: type int[3].
    Now here‚Äôs the tricky part:
    When you use an array (int[3]) in an expression, it decays to a pointer to its first element (int*).
    So:

        *B   ‚Üí int[3]   ‚Üí decays to int*   ‚Üí points to B[0][0]


üîπ Step 3: Why does cout << *B print an address?

    Because after decay:

        *B is int*

    And std::cout has an overload for printing int*, which prints the address.
    If you wanted the value, you need one more dereference:

        cout << **B << endl;   // prints 1 (the first element B[0][0])


üîπ Analogy

    Think of B as:

        B   = pointer to row
        *B  = row = decays into pointer to first element
        **B = value of first element



üîπ Example Demo
    int B[2][3] = {{1,2,3}, {4,5,6}};

        cout << B      << endl;  // address of first row
        cout << *B     << endl;  // address of first element (row decays to int*)
        cout << **B    << endl;  // value of first element = 1

    Output (addresses will differ):

        0x7ffee3a1d9c0   // B
        0x7ffee3a1d9c0   // *B
        1                // **B



üîπ Setup
    int B[2][3] = { {1,2,3}, {4,5,6} };
    cout << "*(B+1): " << *(B+1) << endl;



üîπ Step 1: What is B?

    B is a 2D array int[2][3].
    In expressions, it decays into a pointer to the first row ‚Üí type:
        int (*)[3]   // pointer to an array of 3 ints

    So:
        B ‚Üí &B[0] (points to row 0)



üîπ Step 2: What is B+1?

    Since B is a pointer to a row (int[3]):
        B+1 moves one row forward (skips 3 ints).

    So:
        B+1 ‚Üí &B[1] (address of row 1)



üîπ Step 3: What is *(B+1)?

    *(B+1) dereferences the pointer-to-row.
    So it gives you row 1 ‚Üí type int[3].
    In expressions, that array decays to int* (pointer to its first element).

    So:
        *(B+1) ‚Üí B[1] ‚Üí int* pointing to B[1][0]



üîπ Step 4: Printing it

    cout << *(B+1); means you‚Äôre passing an int* to cout.
    And as we said earlier: cout prints the address, not the value (for int*).
    So the output will be:

        *(B+1): 0x7ffee3a1d9d0   // (example address of B[1][0])



üîπ How to get values instead

    If you actually want to print elements of row 1:

        cout << *(*(B+1)) << endl;     // prints 4   (B[1][0])
        cout << *(*(B+1) + 1) << endl; // prints 5   (B[1][1])
        cout << *(*(B+1) + 2) << endl; // prints 6   (B[1][2])


‚úÖ Final Answer
        cout << "*(B+1): " << *(B+1) << endl;

    prints the address of B[1][0] (the first element of the second row), not the value, because *(B+1) decays into int* and cout prints 
    pointers as addresses.



***Note:
    For 2-D arrays we have:
        B[i][j] = *(B[i]+j)
        B[i][j] = *(*(B+i)+j)


üîπ Step 1: What is B in a 2D array?
    int B[2][3] = { {1,2,3}, {4,5,6} };

    Type of B is array of 2 elements, each of type array of 3 ints ‚Üí int[2][3].

    In expressions, B decays into ‚Üí pointer to the first row (int (*)[3]).

    So:
        B ‚Üí &B[0] ‚Üí pointer to row 0
        *B ‚Üí B[0] ‚Üí row 0 itself (type: int[3], decays to int*)



üîπ Step 2: First equivalence B[i][j] = *(B[i] + j)

    B[i] means "the ith row" (type: int[3], decays to int*).
    So B[i] is a pointer to the first element of row i.
    Adding j ‚Üí (B[i] + j) means "move j ints forward in row i".
    Dereferencing ‚Üí *(B[i] + j) = the jth element of row i.

    Thus:
        B[i][j] == *(B[i] + j)

    ‚úî Works exactly like with 1D arrays.


üîπ Step 3: Second equivalence B[i][j] = *(*(B+i)+j)

    B+i means "move i rows forward". Since each row is int[3], this skips i*3 integers.
    *(B+i) dereferences ‚Üí gives row i (type: int[3], decays to int*).
    Now we‚Äôre back to the row pointer, same as B[i].
    Then add j ‚Üí (*(B+i)+j).
    Finally dereference ‚Üí *(*(B+i)+j) = element j of row i.

    Thus:
        B[i][j] == *(*(B+i)+j)



üîπ Example in code
        #include <iostream>
        using namespace std;

        int main() {
            int B[2][3] = { {1,2,3}, {4,5,6} };

            cout << B[1][2] << endl;         // normal access ‚Üí 6
            cout << *(B[1] + 2) << endl;     // same ‚Üí 6
            cout << *(*(B+1) + 2) << endl;   // same ‚Üí 6
        }

    Output:

        6
        6
        6


Step 2: What is B[0]?

    B[0] means: ‚Äúthe 0th row‚Äù ‚Üí type is int[3].

    When used in an expression, B[0] decays into int*.
    ‚Üí pointer to the first element of row 0 (&B[0][0]).

    So:
        B[0] == &B[0][0]



Example array:
int B[2][3] = { {1,2,3}, {4,5,6} };

üîπ Table of expressions
Expression	Type	Meaning	What cout prints (without *)
B	int (*)[3]	Pointer to the first row (&B[0])	Address of row 0
&B	int (*)[2][3]	Pointer to the whole 2√ó3 array	Address of the entire array (same numeric value as B, but different type)
&B[0]	int (*)[3]	Pointer to the first row	Address of row 0 (same as B)
&B[0][0]	int*	Pointer to the first element of row 0	Address of first integer
*B	int[3] ‚Üí decays to int*	The first row (array of 3 ints ‚Üí decays to pointer to first element)	Address of first integer (&B[0][0])
*B[0]	int	First element of row 0 (B[0][0])	Value 1
*B[0][0] ‚ùå	Not valid	B[0][0] is already an int, you can‚Äôt dereference an int.	Compiler error
üîπ In code:
#include <iostream>
using namespace std;

int main() {
    int B[2][3] = { {1,2,3}, {4,5,6} };

    cout << "B: " << B << endl;                // address of row 0
    cout << "&B: " << &B << endl;              // address of whole array
    cout << "&B[0]: " << &B[0] << endl;        // address of row 0
    cout << "&B[0][0]: " << &B[0][0] << endl;  // address of first int

    cout << "*B: " << *B << endl;              // address of first int (row 0 decays to int*)
    cout << "*B[0]: " << *B[0] << endl;        // first int value ‚Üí 1
    // cout << "*B[0][0]" << *B[0][0] << endl; // ‚ùå invalid, would not compile
}

üîπ Example Output (addresses vary)
B: 0x7ffee2cba0
&B: 0x7ffee2cba0
&B[0]: 0x7ffee2cba0
&B[0][0]: 0x7ffee2cba0
*B: 0x7ffee2cba0
*B[0]: 1


‚úÖ Key points to remember:

B, &B, and &B[0] all print the same numeric address, but have different types.

B ‚Üí pointer to row

&B ‚Üí pointer to whole array

&B[0] ‚Üí pointer to row 0

*B = row 0 (decays to int* ‚Üí prints address of first element).

*B[0] = value of first element in row 0.

You cannot dereference an int (*B[0][0] ‚ùå).



üëâ B and &B[0] evaluate to the same address, but their types are different.

üîπ Why?

Take:

int B[2][3] = { {1,2,3}, {4,5,6} };


B ‚Üí in most expressions, decays to type int (*)[3]
(pointer to an array of 3 ints, i.e. a row).
It points to the first row.

&B[0] ‚Üí ‚Äúaddress of row 0‚Äù ‚Üí also type int (*)[3].
It also points to the first row.

So in this case:

B == &B[0]   // true, both are the same pointer value

üîπ But &B is different:

&B ‚Üí type int (*)[2][3] (pointer to the whole 2√ó3 array).
Same numeric address, but points to the whole block, not just one row.

üîπ Demo
#include <iostream>
using namespace std;

int main() {
    int B[2][3] = { {1,2,3}, {4,5,6} };

    cout << "B: " << B << endl;
    cout << "&B[0]: " << &B[0] << endl;
    cout << "&B: " << &B << endl;

    if (B == &B[0]) cout << "B and &B[0] are equal\n";
}


Output (addresses differ per run):

B: 0x7ffee2cba0
&B[0]: 0x7ffee2cba0
&B: 0x7ffee2cba0
B and &B[0] are equal


‚úÖ Summary:

B and &B[0] ‚Üí same address, same type (int (*)[3]).

&B ‚Üí same numeric address, but different type (int (*)[2][3]).




#include <iostream>
using namespace std;
int main()
{
    int B[2][3]={{1,2,3},{4,5,9}};
    
    cout << "B: " << B << endl;
    cout << "&B[0]: " << &B[0] << endl;
    cout << "&B: " << &B << endl;
    cout << "&B+1: " << &B+1 << endl;
    //cout << "&(B+1): " << &(B+1) << endl; // This will generate error
    cout << "&B[0][0]: " << &B[0][0] << endl;
    cout << "*B: " << *B << endl;
    cout << "**B: " << **B << endl;
    cout << "*B[0]: " << *B[0] << endl;
    cout << "*(B+1): " << *(B+1) << endl;
    cout << "*(B+1)+2: " << *(B+1)+2 << endl;
    cout << "*(*(B+1)+2): " << *(*(B+1)+2) << endl;
    cout << "**(B+1)+2: " << **(B+1)+2 << endl;
    cout << "**((B+1)+1): " << **((B+1)+1) << endl;
    cout << "*(*B+1): " << *(*B+1) << endl;
    cout << "B+1: " << B+1 << endl;
    cout << "B[0]: " << B[0] << endl;
    cout << "B[1]: " << B[1] << endl;
    cout << "&B[0][1]: " << &B[0][1] << endl;
    cout << "&B[0][2]: " << &B[0][2] << endl;
    cout << "&B[1][0]: " << &B[1][0] << endl;
    cout << "&B[1][1]: " << &B[1][1] << endl;
    cout << "&B[1][2]: " << &B[1][2] << endl<<endl;
    
    
    return 0;
}

Output:
    B: 0x7fff3634f600
    &B[0]: 0x7fff3634f600
    &B: 0x7fff3634f600
    &B+1: 0x7fff3634f618
    &B[0][0]: 0x7fff3634f600
    *B: 0x7fff3634f600
    **B: 1
    *B[0]: 1
    *(B+1): 0x7fff3634f60c
    *(B+1)+2: 0x7fff3634f614
    *(*(B+1)+2): 9
    **(B+1)+2: 6
    **((B+1)+1): -488209664
    *(*B+1): 2
    B+1: 0x7fff3634f60c
    B[0]: 0x7fff3634f600
    B[1]: 0x7fff3634f60c
    &B[0][1]: 0x7fff3634f604
    &B[0][2]: 0x7fff3634f608
    &B[1][0]: 0x7fff3634f60c
    &B[1][1]: 0x7fff3634f610
    &B[1][2]: 0x7fff3634f614



** in the expression B+1 we have B which gives us the address of the first element in row 1 and the type is int (*)[3] and +1 means
go to the next row which is row 1


















*/