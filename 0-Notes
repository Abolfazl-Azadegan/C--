// In C++ we usually read input into std::string objects, e.g.:
// std::string s;
// std::cin >> s;
// But sometimes we want exactly N characters (even if spaces or newlines are included).
// The normal >> operator won‚Äôt work for that, because it skips whitespace and stops at spaces.
// That‚Äôs where cin.get() is used.


// 2. cin.get() behavior
    // cin.get() has multiple forms:
        // cin.get() ‚Üí reads one single character.
        // cin.get(char* buffer, int size) ‚Üí reads up to size-1 characters into a C-style char array.

    // cin.get(char* buffer, int size) requires a char array, because it places characters directly in that memory.
        // char buffer[11]; // array of 11 chars
        // std::cin.get(buffer, 11); // read up to 10 characters (one spot left for '\0')

    // Now buffer contains those characters as a C-string (null-terminated).
    // But if you want a std::string (the C++ object), you must convert:
        // std::string s(buffer);

/*
#include <iostream>
#include <string>
using namespace std;

int main() {
    char buffer[11]; // reserve space for 10 chars + null terminator

    cout << "Enter text: ";
    cin.get(buffer, 11); // reads up to 10 chars (stops before newline or size)

    string s(buffer); // convert char array to std::string
    cout << "You entered: " << s << endl;

    return 0;
}
*/
/*
If you type:
    Hello World!

It will only read:
    Hello Worl

(10 characters).
*/

/*
Summary:
    cin.get() with parameters needs a char array.
    It cannot write directly into a std::string.
*/

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
You can save into a std::string, but the catch is:

cin.get(char* buffer, int size) is an old C-style function.

It expects a raw memory buffer (char[]) where it will physically copy characters.

A std::string is an object, not just a raw character array. You cannot pass it directly, because cin.get doesn‚Äôt know how to 
‚Äúfill‚Äù the internals of the object safely.
*/

/*
1. Why std::string doesn‚Äôt work with cin.get
    If you try this:
    string s;
    cin.get(s, 11);  // ‚ùå error: no matching function
    It won‚Äôt compile, because there is no overload of cin.get that accepts a std::string.
*/

/*
2. But there is an alternative: cin.read()
    C++ gives another method designed for reading raw characters into memory that works better with std::string.

    Example:

    #include <iostream>
    #include <string>
    using namespace std;

    int main() {
        string s(10, '\0'); // make a string with 10 slots (filled with '\0')

        cout << "Enter text: ";
        cin.read(&s[0], 10); // read 10 characters directly into the string‚Äôs buffer

        cout << "You entered: " << s << endl;
        return 0;
    }

    If you type:
        Hello World!


    It will output:
        Hello Worl

    üëâ Here we avoided the intermediate char array ‚Äî we read directly into the std::string memory.
*/

/*
3. When to use which

    Use cin.get(char*, int) ‚Üí if you‚Äôre working with raw C-style arrays.
    Use cin.read(&s[0], n) ‚Üí if you want to read directly into a std::string.
*/


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
1. What is char[]?

    char[] is a C-style character array.

    It is literally a block of memory that can hold multiple characters (letters, digits, symbols, spaces).

    Example:
    char word[6]; 
    This reserves 6 bytes in memory (1 byte per char).
*/

/*
2. Why is it special for text?

    In C and C++, strings in the C-style are just arrays of characters ending with a special character: '\0' (null terminator).
    So, if we write:
    char word[6] = "Hello";

    Memory looks like this:

    Index	Value
    0	'H'
    1	'e'
    2	'l'
    3	'l'
    4	'o'
    5	'\0'

    üëâ That '\0' tells functions where the string ends.
*/

/*
Example of risk with char[]:

char name[5];
cin >> name; // if you type "Hello", overflow happens (needs 6 chars: "Hello\0")

Quick analogy

char[] ‚Üí Like a fixed-size box of letters; you must decide the size before writing, and you must put a ‚ÄúTHE END‚Äù card ('\0') yourself.

std::string ‚Üí Like a flexible notebook that can grow automatically and keeps track of its own ending.



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

1. What is function overloading?

    In C++, overloading means you can define multiple functions with the same name, but with different parameter lists.
    The compiler then decides which version to call depending on the arguments you pass.

    Example:

        #include <iostream>
        using namespace std;

        void print(int x) {
            cout << "Integer: " << x << endl;
        }

        void print(double y) {
            cout << "Double: " << y << endl;
        }

        void print(string s) {
            cout << "String: " << s << endl;
        }

        int main() {
            print(5);        // calls print(int)
            print(3.14);     // calls print(double)
            print("Hello");  // calls print(string)
        }

Here print is overloaded with 3 different signatures:

    print(int)
    print(double)
    print(string)



2. How it applies to cin.get

    The standard library has several overloads of cin.get.
    Some of them are:

        cin.get() ‚Üí reads one character.
        cin.get(char &c) ‚Üí stores one character in a variable you provide.
        cin.get(char* buffer, int size) ‚Üí reads up to size-1 characters into a character array.

    üëâ Notice: there is no version (overload) of cin.get that takes a std::string. That‚Äôs why this fails:

        std::string s;
        cin.get(s, 11);  // ‚ùå compiler error: no matching function

    Because the compiler looks through all the overloaded cin.get functions and sees:
    ‚ÄúI don‚Äôt have one that matches (std::string, int).‚Äù


3. Term clarified
    So when I said:

        ‚Äúthere is no overload of cin.get that accepts a std::string.‚Äù
        I meant:
        The cin.get family has several versions (overloads).
        But none of them are written to accept a std::string as an argument.


‚úÖ Summary:

    Overload in C++ means: same function name, different parameter list.
    The compiler picks the correct version at compile time.
    cin.get is overloaded for char, char*, etc.
    It is not overloaded for std::string, so you can‚Äôt use it that way.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


3. What will be stored

    If you type "Hello World!" into text[6], you won‚Äôt get just "Hello". Instead, you‚Äôll overflow the array.
    The first 6 slots will be filled ('H', 'e', 'l', 'l', 'o', maybe part of the space or null).
    Then input keeps writing into memory that doesn‚Äôt belong to text.
    That‚Äôs the danger ‚Äî unlike std::string, a char[] has no built-in safety check.

4. Safer alternative

    With std::string, you don‚Äôt have this problem:
        std::string text;
        cin >> text;
    Now if you type "Hello World!", it will safely store "Hello" (because >> stops at the space).
    Or if you use getline(cin, text);, it will safely store the entire line, growing the string automatically.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Pointer is a variable that points to the address of another variable. it stores address of another variable

int a;
int *p;
p = &a;
a = 5;
print p;  //204 because this holds the address of the variable a
print &a;  //204 
print &p;  //64 this points to the address of variable p
print *p;  //5 this returns the value of the variable a

so:
p -> Address which p holds
*p -> value at address which p holds



1. Declaring a pointer

    If you want a pointer to an int, you declare it like this:
        int *p;   // p is a pointer to int
    Here, p itself does not point anywhere yet. It's uninitialized, so using it before assigning is dangerous.

2. Making it point to an existing variable

    You make a pointer point to a variable by using the address-of operator (&):

        int b = 10;
        int *p = &b;  // p now points to b

    So now:
    p holds the memory address of b.
    *p (dereferencing) gives you the value of b.


#include <iostream>
using namespace std;
int main()
{
    int a = 10;
    int *b;
    b= &a;
    cout << "a= " << a << endl;
    cout << "b= " << b << endl;
    cout << "b= " << &b << endl;
    cout << "b= " << *b << endl;
    
    *b = 40; // Here we have changed value of the variable which b is refering to. so b also will change
    
    cout << "a= " << a << endl;
    cout << "b= " << b << endl;
    cout << "b= " << &b << endl;
    cout << "b= " << *b << endl;
    return 0;
}


3. Important distinction

    int p; ‚Üí p is a regular integer variable (not a pointer).
    int *p; ‚Üí p is a pointer to an integer.
    You cannot do something like:

        int b = 10;
        int p = &b; // ‚ùå WRONG: &b is an address, but p is just an int

    That would be a type mismatch ‚Äî &b has type int*, not int.



    *p = 20;
‚Üí *p means ‚Äúthe value at the memory location that p points to‚Äù.
Since p points to a, this line sets a = 20.

Final result:

    a == 20 ‚úÖ
    b == 20 ‚úÖ (unchanged after declaration)
    *p == 20 ‚úÖ (because p points to a)

So yes ‚Äî the value of a will change.

‚ö° Key point:
    *p = 20; modifies the variable that p points to (in this case a).

We can also write in both of the below forms:
int* p = &a;
int *p = &a;



If we use just the name of the array it will point to the address of the first element in the array

    int A[5] = {10, 20, 30, 40, 50};
    int *p;
    p=A;
    cout << A << endl; // Address of the first element in the array like 200
    cout << *A << endl; // Value stored in the first element of the array like 10
    cout << A+1 << endl; // Address of the second element in the array like 204
    cout << *(A+1) << endl; // Value stored in the second element of the array like 20

    cout << A << endl; // Address of the first element in the array like 200
    cout << &A[0] << endl; // Address of the first element in the array like 200
    cout << A[0] << endl; // Value of the first element in the array like 10
    cout << *A << endl; // Value of the first element in the array like 10


    A++; // This is invalid and makes error
    p++; // This is valid and will work

Step 3: p = A;
    Since A can be treated as the address of its first element:
    A is equivalent to &A[0]
    So now p = &A[0] (i.e., p points to the first element of the array).


Step 4: print A;
    If you try to std::cout << A; in C++:
    It will print the memory address of the first element (like 0x7ffee....), not the whole array.
    A is essentially a pointer here.


Step 5: print *A;
    *A means ‚Äúthe value stored at address A‚Äù
    Since A == &A[0], dereferencing gives the first element: A[0].
    So *A is exactly the same as A[0].    



** To get the address of the second element in array we can use either of the below ways.

    &A[i]
    (A+1)

** To get the value of the second element in array we can use either of the below ways.

    A[i]
    *(A+1)

The address of the first element in the array can be called the base address

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Arrays as function arguments

** Arrays are always passed to functions by the reference and not whole the array will be passed to the the function.
it means that only the address of the first member of the array will be passed to the function

int A[5];
int *p = A; // This will put the address of the first element of A which is A[0] in the variable p
print A; // this will be the address of the first element in array A for example 200
print *A // this will be the value which the first address of the array A is storing for example 10
print *(A+2) // this will be the value of the third element of array A which for example is 6

** So for conclusion (A+i) is the same as A[i] which gives the address of the i+1 member of the array A
** so for conclusion *(A+i) is the same and &A[i] which gives the address of the i+1 member of the array A




    int A[5] = {10, 20, 30, 40, 50};
    int size = sizeof(A);
    int sizeofarray = sizeof(A)/sizeof(A[0]);
    cout << size << endl;
    cout << sizeofarray << endl;



int B [2][3] // Here we are creating two 1-D arrays which each one has 3 member
B[0]
B[1]

each on these 1-D arrays have 12 bytes length because of 3*4bytes = 12 bytes
so for example B[0] starts from address 400 to 411 and the array B[1] starts from 412 to 423


** Name of the array points to the address of the first member of the array

B is a 2D array of type int[2][3].
In most expressions, B decays into a pointer to its first row.
So B is of type int (*)[3] (pointer to an array of 3 ints).



    #include <iostream>
    using namespace std;

    int main() {
        int B[2][3];   // a 2x3 array

        int *p = B;    // ‚ùå problem is here

        return 0;
    }

here we have this situation:

    int *p = B;   // trying to assign int (*)[3] to int*

p expects a pointer to an int.
But B decays to a pointer to an array of 3 ints (int (*)[3]).
These are not the same type, so the compiler complains.



Correct ways
    If you really want p to point to the first element (an int):

        int *p = &B[0][0];  // point to the very first int in the 2D array

    If you want a pointer to a row:

        int (*p)[3] = B;    // p is a pointer to an array of 3 ints

    Now you can do:

        cout << (*p)[0];   // first element of first row
        p++;  


üîπ Example 1: Accessing elements with int* p = &B[0][0];
    #include <iostream>
    using namespace std;

    int main() {
        int B[2][3] = { {1, 2, 3}, {4, 5, 6} };

        int *p = &B[0][0];   // pointer to the first int in the 2D array

        // Print elements using pointer arithmetic
        for (int i = 0; i < 6; i++) {
            cout << *(p + i) << " ";
        }
        cout << endl;
    }

üîπ Output:
    1 2 3 4 5 6



üîπ Example 2: Pointer to a row (int (*p)[3] = B;)
    #include <iostream>
    using namespace std;

    int main() {
        int B[2][3] = { {1, 2, 3}, {4, 5, 6} };

        int (*p)[3] = B;   // p points to a row of 3 integers

        // Access elements row by row
        cout << "First row: " << (*p)[0] << " " << (*p)[1] << " " << (*p)[2] << endl;

        p++;   // move to next row (skips 3 ints)

        cout << "Second row: " << (*p)[0] << " " << (*p)[1] << " " << (*p)[2] << endl;
    }

üîπ Output:
    First row: 1 2 3
    Second row: 4 5 6

üîπ Explanation:

    p is a pointer to an array of 3 ints.
    *p dereferences to the whole row (int[3]).
    (*p)[i] accesses elements within that row.
    p++ moves to the next row (jumps by 3 ints at once).



üîπ 1. What does [3] mean in this declaration?
    int (*p)[3] = B;

    p is a pointer.
    (*p)[3] means: "p points to an array of 3 integers".
    So p has type pointer to array of 3 ints (int (*)[3]).
    This is different from int *p (pointer to a single int).


üîπ 2. Is the row an array?

Yes ‚úÖ Each row in B is an array of 3 integers.

For example:

    int B[2][3] = { {1,2,3}, {4,5,6} };

    B[0] ‚Üí the first row, type int[3].
    B[1] ‚Üí the second row, type int[3].

So when you write:
    int (*p)[3] = B;

    p = &B[0] // This means put the address of B[0] which is an aray of 3 ints in pointer p so pointer p should be defined as pointer 
    with dimention of array of 3 ints

    *p = B[0] (which is an array of 3 ints).



üîπ 3. Why can‚Äôt I just cout << *p; to print the row?

    This is because of how arrays behave in C++:
    *p is of type int[3] (array of 3 ints).
    But in most expressions, an array decays into a pointer to its first element.
    So *p decays into int* ‚Üí pointer to (*p)[0].
    That‚Äôs why:

        cout << *p;
    prints the address of the first element (&B[0][0]), not the whole array.

    ‚ö° Key point: C++ does not know how to print arrays directly with cout.
    It only knows how to print scalars (int, double, etc.) and addresses (int*).



üîπ 4. ‚Äú*p dereferences to the whole row‚Äù ‚Äî what does that mean?

    p ‚Üí pointer to a row (int (*)[3]).
    *p ‚Üí the row itself (int[3]).

    But as soon as you use *p in an expression (like with cout), it decays to int* (address of first element).
    So in practice:
    *p is conceptually the whole row {1,2,3}.
    But C++ treats it as just the address of the first element.
    That‚Äôs why you need a loop to see all elements:

        for (int i = 0; i < 3; i++) {
            cout << (*p)[i] << " ";
        }

    Output:
        1 2 3



1. Can you do cout << B[0]; ?

        int B[2][3] = { {1,2,3}, {4,5,6} };
        cout << B[0] << endl;

    B[0] is the first row. Its type is int[3].
    In most expressions (like here), it decays to a pointer ‚Üí type int* (pointer to the first element of that row).
    So cout << B[0]; will just print the address of B[0][0], not the values {1,2,3}.
    ‚úÖ If you want the row values, you must loop:

        for (int i = 0; i < 3; i++) {
            cout << B[0][i] << " ";
        }

    Output:

        1 2 3











*/